---
title: "Étude du comportement de plusieurs essences en plantation de bois d'oeuvre, Guyane Française"
author:
  - name: "Maël Leborgne"
    authsuperscript: 1*
    orcid: 0000-0000-0000-0000
  - name: "Rozenn Bourquin"
    authsuperscript: 2
affiliation:
  - affsuperscript: 1
    dptuniv: "Department / University"
    address: >
      Street address,
      Zip code,
      Country.
  - affsuperscript: 2
    dptuniv: "Department / University"
    address: >
      Street address,
      Zip code,
      Country.
corrauthor:
    email: name@company.com
    url: https://www.company.com
abstract: >
  Summary of the article.
  Mandatory.
  
  
  Use double line feed for a new paragraph.
keywords: [keyword1, keyword2, etc]
JEL: [Code1, Code2, etc, MayBeDeleted]
acknowledgements: >
  Acknowledgements. 
  
  
  May be deleted.
journalinfo: "Publication reference"
archive: "DOI: xxx/xx"
# Date format: '%Y %B %d' for distill
date: "`r format(Sys.time(), '%Y %B %d')`"
url: https://GitHubID.github.io/Repository/
github-repo: GitHubID/Repository
lang: en-US
otherlangs: [fr-FR,it]
keywordlabel: Keywords
JELlabel: JEL
acknowledgementslabel: Acknowledgements
corrauthorlabel: Corresponding author
# Author separator: \par (no quote) for one author per line, "," (between quotes) else
authorseparator: \par
bibliography: references.bib
biblio-style: chicago
toc-depth: 3
fontsize: 10pt
urlcolor: blue
preamble: >
  \hyphenation{bio-di-ver-si-ty sap-lings}
always_allow_html: yes
csquotes: true
output:
  bookdown::html_document2:
    base_format: distill::distill_article
    toc: yes
    toc_float: yes
    code_folding: show
    highlight_downlit: yes
  rmdformats::downcute:
    use_bookdown: yes
    lightbox: yes
  bookdown::gitbook:
    config:
      download: "pdf"
      sharing:
        github: yes
  bookdown::pdf_book:
    template: latex/template.tex
    citation_package: natbib
    latex_engine: xelatex
    keep_tex: yes
  bookdown::word_document2: default
editor_options: 
  markdown: 
    wrap: sentence
---

```{r}
#| label: DoNotModify
#| include: false
### Utilities. Do not modify.
# Installation of packpred if necessary
install_packpred <- function(packpred) {
  install_package <- function(package) {
    if (!package %in% installed.packages()[, 1]) {
      install.packages(package, repos = "https://cran.rstudio.com/")
    }
  }
  invisible(sapply(packpred, install_package))
}

# Basic packpred
install_packpred(c("bookdown", "formatR", "kableExtra", "ragg"))

# Chunk font size hook: allows size='small' or any valid Latex font size in chunk options
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(
    options$size != "normalsize", 
    paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), 
    x
  )
})
```

```{r}
#| label: Options
#| include: false
### Customized options for this document
# Add necessary packpred here
packpred <- c("tidyverse")
# Install them
install_packpred(packpred)

# knitr options
knitr::opts_chunk$set(
  cache =   FALSE,    # Cache chunk results
  include = TRUE,     # Show/Hide chunks
  echo =    TRUE,     # Show/Hide code
  warning = FALSE,    # Show/Hide warnings
  message = FALSE,    # Show/Hide messpred
  # Figure alignment and size
  fig.align = 'center', out.width = '80%',
  # Graphic devices (ragg_png is better than standard png)
  dev = c("ragg_png", "pdf"),
  # Code chunk format
  tidy = TRUE, tidy.opts = list(blank = FALSE, width.cutoff = 50),
  size = "scriptsize", knitr.graphics.auto_pdf = TRUE
  )
options(width = 50)

# ggplot style
library("tidyverse")
theme_set(theme_bw())
theme_update(
  panel.background = element_rect(fill = "transparent", colour = NA),
  plot.background = element_rect(fill = "transparent", colour = NA)
)
knitr::opts_chunk$set(dev.args = list(bg = "transparent"))

# Random seed
set.seed(973)
```

# Introduction

## Contexte

La Guyane française est un territoire de 84 millions d'hectares (Mha).
La majorité (96%) de la surface de cette région d'Amérique latine est recouverte par la forêt Amazonienne.
Depuis 2005, l'office nationale des forêts (ONF) exploite le domaine forestier permanent (DFP) qui correspond à une zone de 2,4 Mha et qui forme une bande entre les zones habitées sur le littorale et les forêts non exploitées.
Cette zone de forêt naturelle est exploitée selon des règles de gestion durable du label PEFC.
Ces règles comprennent des rotations de 65 ans entre 2 coupes, une intensité d’exploitation de 5 tiges/ha et la mise en place de séries d’intérêt écologique d’où l’exploitation forestière est exclue.
L’exploitation forestière, malgré un large éventail d’espèces (100) technologiquement utilisables et de qualité remarquable, n’exploite que 15 à 30 espèces et se concentre sur seulement 3 espèces.
Or les pratiques d’exploitation actuelles ne permettent pas la reconstitution du volume commercial en fin de rotation (Piponiot et al 2019).

Aux enjeux de conservation et protection de la forêt, s'ajoute un enjeu de démographie.
En effet, la Guyane connaît une forte croissance démographique (+1,7% par ans entre 2020 et 2023) (INSEE, 2019).
Cette croissance démographique entraîne une augmentation de la demande en logement, et donc en bois d’œuvre.
Ainsi la filière Forêt-Bois prévoit le développement des modèles de plantation forestière dans son Programme Régionale de la Forêt et du Bois 2019-2029 (PRFB) avec un objectif de 5 000 hectares de plantation supplémentaires.

Le dévellopement du modèle de plantation forestière nécessite un état des lieux des plantations actuelles de l'ONF en Guyane.
Le derniers rapport de suivi fait le bilan de XX parcelles expérimentales pour XX espèces avec un recul de XX années pour certaines d'entre elles (Nicolini, 2023).
L'édition d'un nouvel article est motivé par la nécessité de mettre à jour la base de données avec un nouvel inventaire et de synthétiser l’ensemble des données afin d'émettre des recommandations sur les essences à développer en plantation de Bois d’œuvre.

## Objectifs

1.  Comparer les performances des essences

2.  Adapter le choix des essences aux sites (sol, précipitations, FWI)

3.  Tester des scénarios de gestion (densité de plantation, plantation multispecifiques, modalités de préparation de la parcelle, fréquence d'entretient)

# Matériel et méthode {#markdown}

# Modèles sur données fictives

```{r}
#| echo: false

# ---- Initialisation du Programme ----

library(tidyverse)
library(ggplot2)

set.seed(123)

# ---- Paramètres sylvicoles ----
essences <- paste0("Essence", 1:10)
ages_obs <- c(5,10,20,30,40,50)
ages_pred <- 0:100

```

## Modèle de Croissance

Un **modèle de croissance forestier** est un outil mathématique qui permet de prédire l’évolution d’un arbre ou d’un peuplement au cours du temps (source).
On peut donc estimer l'évolution de la croissance en diamètre, en hauteur, ou en volume du bois à partir de **mesures dendrométriques**, de **variables écologiques** et du **scénario de gestion**.

**Modèle de Chapman-Richards :**

$$
Y=A*(1-e^{-kX})^m
$$

Y : Diamètre, X : âge, (A,k,m) = paramètres à estimer (asymptote, vitesse, forme)

**Exemples avec données fictives :**

```{r}
#| label: fig-diam-fictive
#| fig-cap: Modèles de croissance en diamètre avec données fictives (10 essences)
#| echo: false

# ---- Données fictives : diamètre ----
Obs_diam <- expand_grid(age = ages_obs, essence = essences) %>%
  mutate(
    A = runif(n(), 35, 42),
    k = runif(n(), 0.05, 0.07),
    m = runif(n(), 1.2, 1.4),
    diam = A * (1 - exp(-k * age))^m + rnorm(n(), 0, 0.8)
  )

# Modèles Chapman-Richards par essence
mods_diam <- Obs_diam %>%
  group_by(essence) %>%
  group_map(~ tryCatch(
    nls(diam ~ A*(1 - exp(-k*age))^m, data = .x, start = list(A=40,k=0.06,m=1.3)),
    error = function(e) NULL
  ))
names(mods_diam) <- essences

# Prédictions diamètre
Pred_diam <- expand_grid(age = ages_pred, essence = essences) %>%
  group_by(essence) %>%
  mutate(diam = if (!is.null(mods_diam[[unique(essence)]]))
           predict(mods_diam[[unique(essence)]], newdata = data.frame(age=age))
         else NA)

# ---- Graphique : diamètre ----
ggplot() +
  geom_line(data = Pred_diam, aes(x = age, y = diam, color = essence), linewidth = 1) +
  geom_point(data = Obs_diam, aes(x = age, y = diam, color = essence), size = 1) +
  theme_minimal() +
  labs(x = "Âge (ans)", y = "Diamètre (cm)", color = "Essence") +
  theme(plot.title = element_text(face = "bold", size = 14))


```

```{r}
#| label: fig-haut-fictive
#| fig-cap: Modèles de croissance en hauteur avec données fictives (10 essences)
#| echo: false

# ---- Données fictives : hauteur ----
Obs_haut <- expand_grid(age = ages_obs, essence = essences) %>%
  mutate(
    A = runif(n(), 20, 35),       # hauteur asymptotique (m)
    k = runif(n(), 0.03, 0.08),   # taux de croissance
    m = runif(n(), 1, 1.5),     # forme de la courbe
    haut = A * (1 - exp(-k * age))^m + rnorm(n(), 0, 0.2) # bruit réaliste
  )

# ---- Modèles Chapman-Richards par essence ----
mods_haut <- Obs_haut %>%
  group_by(essence) %>%
  group_map(~ tryCatch(
    nls(haut ~ A*(1 - exp(-k*age))^m, data = .x, start = list(A=22,k=0.05,m=1.2)),
    error = function(e) NULL
  ))
names(mods_haut) <- essences

# ---- Prédictions hauteur ----
Pred_haut <- expand_grid(age = ages_pred, essence = essences) %>%
  group_by(essence) %>%
  mutate(haut = if (!is.null(mods_haut[[unique(essence)]]))
           predict(mods_haut[[unique(essence)]], newdata = data.frame(age=age))
         else NA)

# ---- Graphique : hauteur ----
ggplot() +
  geom_line(data = Pred_haut, aes(x = age, y = haut, color = essence), linewidth = 1) +
  geom_point(data = Obs_haut, aes(x = age, y = haut, color = essence), size = 1) +
  theme_minimal() +
  labs(
    x = "Âge (ans)",
    y = "Hauteur (m)",
    color = "Essence"
  ) +
  theme(plot.title = element_text(face = "bold", size = 14))

```

## Modèle de Mortalité

Un modèle de mortalité est un outil mathématique qui prédit la probabilité qu’un arbre meure au cours d’une période donnée (source).
Il peut prendre en compte :

-   la **taille de l’arbre** (les petits meurent plus souvent par compétition),

-   la **densité du peuplement** (stress dû à la concurrence),

-   les **conditions écologiques** (sécheresse, inondation, sols pauvres, etc.),

-   les **caractéristiques propres à l’essence** (tolérance à l’ombre, longévité, résistance aux maladies).

Ici on ne peut que prendre en compte la taille de l'arbre, voir les extrêmes de pluviométrie annuelle (haut, bas).
(autre idée ?)

**Modèle logistique :**

$$
Y=\frac{A}{1+Be^{-kX}}
$$

Y : Taux de mortalité, X : Âge, (A,B,k,m) = paramètres à estimer (asymptote, vitesse, forme)

**Exemple avec données fictives :**

```{r}
#| label: fig-mort-fictive
#| fig-cap: Modèles de mortalité avec données fictives (10 essences)
#| echo: false

# ---- Données fictives : mortalité ----
Obs_mort <- expand_grid(age = ages_obs, essence = essences) %>%
  mutate(
    a = runif(n(), -6, -3),
    b = runif(n(), 0.05, 0.15),
    mort = 100 / (1 + exp(-(a + b*age)))
  ) %>%
  select(age, essence, mort)

# Modèles logistiques par essence
mods_mort <- Obs_mort %>%
  group_by(essence) %>%
  group_map(~ tryCatch({
    nls(mort ~ 100 / (1 + exp(-(a + b*age))),
        data = .x,
        start = list(a = -5, b = 0.1))
  }, error = function(e) NULL))
names(mods_mort) <- essences

# Prédictions mortalité
Pred_mort <- expand_grid(age = ages_pred, essence = essences) %>%
  group_by(essence) %>%
  mutate(mort = if (!is.null(mods_mort[[unique(essence)]]))
           predict(mods_mort[[unique(essence)]], newdata = data.frame(age=age))
         else NA)

# ---- Graphique : mortalité ----
ggplot() +
  geom_line(data = Pred_mort, aes(x = age, y = mort, color = essence), linewidth = 1) +
  geom_point(data = Obs_mort, aes(x = age, y = mort, color = essence), size = 1) +
  theme_minimal() +
  labs(x = "Âge (ans)", y = "Mortalité cumulée (%)", color = "Essence") +
  theme(plot.title = element_text(face = "bold", size = 14))

```

## Modèle de production de Bois d’œuvre

La combinaison du modèle de croissance et du modèle de mortalité permet d'obtenir un modèle de production volumique.

Soit le volume individuel d'un arbre :

$$
V_{ind}=\pi*(\frac{D_{130}}{2})²*H_{tot}*f
$$

Avec $D_{130}$ le diamètre du tronc en mètre à 130 cm,\
$H_{tot}$ la hauteur totale de l'arbre,\
et $f$ le facteur de forme.

On concidère le volume de bois produit par hectare (en m³/ha):

$$
V_{ha}=\frac{N_{surv}*V_{ind}}{S}
$$

Avec $V_{ind}$ le volume individuel moyen d'un arbre (en m³),\
$N_{surv}$ le nombre de survivant sur la parcelle,\
et $S$ la surface de la parcelle considérée (en hectares).

```{r}
#| label: fig-prod-fictive
#| fig-cap: Modèles de production de Bois d'oeuvre avec données fictives (10 essences)
#| echo: false

# ---- Paramètres sylvicoles ----
densite_init <- 800 # nombre d'arbre à l'hectare
f <- 0.45 # facteur de forme

# ---- Fonction de volume individuel ----
calc_volume <- function(D,H){
  V <- pi * (D/200)^2 * H * f # volume avec facteur de forme (f=0.45)
  return(V)
}

# ---- Volume observations ----
vol_obs <- left_join(Obs_diam,Obs_haut,by=c("age","essence")) %>%
  left_join(Obs_mort, by = c("age","essence")) %>%
  mutate(
    V_ind = calc_volume(diam,haut),
    N_surv = densite_init * (1 - mort/100), # denstié = 800 (set in the begining)
    Vol_ha = N_surv * V_ind # volume par hectare (avec surface de parcelle = 1ha)
  )

# ---- Volume prédictions ----
vol_pred <- left_join(Pred_diam,Pred_haut,by=c("age","essence")) %>%
  left_join(Pred_mort, by = c("age","essence")) %>%
  mutate(
    V_ind = calc_volume(diam,haut),
    N_surv = densite_init * (1 - mort/100),
    Vol_ha = N_surv * V_ind # volume par hectare (avec surface de parcelle = 1ha)
  )

# ---- Graphique : volume ----
ggplot() +
  geom_line(data = vol_pred, aes(x = age, y = Vol_ha, color = essence), linewidth = 1) +
  geom_point(data = vol_obs, aes(x = age, y = Vol_ha, color = essence), size = 1, shape = 16) +
  theme_minimal() +
  labs(x = "Âge (ans)", y = "Volume total (m³/ha)", color = "Essence") +
  theme(plot.title = element_text(face = "bold", size = 14))


```

Un autre point important en sylviculture est l'estimation de la **rotation optimale**, c'est à dire l'âge idéal de coupe pour maximiser la valeur du Bois.

**Tâche pour avancer dans les résultats :**

-   Séparer les facteurs de forme selon l’espèce.

-   Séparer les densité de tige et les surfaces selon les parcelles.

**Questions pour Thomas :**

-   Comment calcule-t-on le volume de bois exploitable ? 

    -   Facteurs de forme ? Prise en compte des fourches ?

-   Comment obtenir la rotation optimale ? 

    -   Quand la dérivé du modèle vaut zéro ?

-   Comment séparer les facteurs exogènes qui influent sur le volume ?

    -   Sol, Précipitations, FWI -\> carte raster de l’ONF ?

-   Nécessité d’avoir toute les données

# Tests sur les vrais données

## Importation des données

```{r}
#| echo: false
library(tidyverse)

Inv_complet <- read.csv2("/home/jean/Bureau/projet-ONF-FTH/Data/Thomas_22-09_DB_FTH.csv", sep=";",dec = ".")

str(Inv_complet)

# Mise en facteurs de cetraines variables
unique(Inv_complet$Libelle_Plantation)
#Inv_complet$Libelle_Plantation <- as.factor(Inv_complet$Libelle_Plantation)

# Convertion de Age_Plantation en années
unique(Inv_complet$Age_Plantation)
convert_annee <- data.frame(
  "Age_Plantation" = c("Etat initial","6 mois","1 an","1,5 an","2 ans","3 ans","5 ans","7 ans","36 ans","20 ans","40 ans","15 ans","23 ans","7ans"),
  "Age_Plantation_annee" = c(0,0.5,1,1.5,2,3,5,7,36,20,40,15,23,7)
)
Inv_complet <- left_join(Inv_complet,convert_annee,by="Age_Plantation")

# Extraction de Nom_Vern et Code_Arbre à partir de TON, RIS et KAW
# Import
#TON <- read.csv2("/home/jean/Bureau/projet-ONF-FTH/Data/Maël_22-09_TON78_D_ARBO_inv complet.csv", sep=";",dec = ".")
KK <- read.csv2("/home/jean/Bureau/projet-ONF-FTH/Data/Nom_Vern&Code_Arbre/TON_2025_invKK_exp.csv", sep=",",dec = ".") %>% select(Nom_Vern,Code)
WK <- read.csv2("/home/jean/Bureau/projet-ONF-FTH/Data/Nom_Vern&Code_Arbre/TON_2025_invWK_exp.csv", sep=",",dec = ".") %>% select(Nom_Vern,Code)
GK <- read.csv2("/home/jean/Bureau/projet-ONF-FTH/Data/Nom_Vern&Code_Arbre/TON_2025_invGK_exp.csv", sep=",",dec = ".") %>% select(Nom_Vern,Code)
TON <- rbind(KK,WK) %>% rbind(GK)

RIS <- read.csv2("/home/jean/Bureau/projet-ONF-FTH/Data/Maël_07-10_RIS78_D_inventaire_complet.csv", sep=";",dec = ".")
KAW <- read.csv2("/home/jean/Bureau/projet-ONF-FTH/Data/Maël_22-09_KAW03-D_Inventaire complet.csv", sep=";")
# Extract
TON <- TON %>% select(Nom_Vern,Code)
RIS <- RIS %>% select(Nom_Vern,Code)
KAW <- KAW %>% select(Nom_Vern,Code)
# Bind
df_Nom_Vern <- rbind(TON,RIS) %>% rbind(KAW)

# Ajout de Nom_Vern à Inv_complet
df_Nom_Vern <- df_Nom_Vern %>% rename(Code_Arbre="Code") # homogenise column name
Inv_complet <- left_join(Inv_complet,df_Nom_Vern,by="Code_Arbre")

# Verfify if all Code_Arbre is indentify by Nom_Vern
table(df_Nom_Vern$Nom_Vern)
table(Inv_complet$Nom_Vern)
length(unique(Inv_complet$Code_Arbre))
length(unique(df_Nom_Vern$Code_Arbre))
codes_absents <- setdiff(unique(Inv_complet$Code_Arbre), unique(df_Nom_Vern$Code_Arbre))
codes_absents

# Dignostic on referenced trees by dates
table(Inv_complet$Date_Intervention)

```

## Modèle de Croissance

```{r}
#| label: fig-diam-real
#| fig-cap: Modèles de croissance en diamètre avec données réelles (6 essences, 3 parcelles)
#| echo: false

# Retirer les NA dans les colonnes Nom_Vern et Circonférence
# Inv_complet <- Inv_complet[!is.na(Inv_complet$Nom_Vern), ]
Inv_complet <- Inv_complet[!is.na(Inv_complet$Circonférence), ]

# Remplacer les virgules par des points dans la colonne Circonférence
Inv_complet$Circonférence <- gsub(",", ".", Inv_complet$Circonférence)

# ---- Selection des Données de diamètres par essence ----
Obs_diam <- data.frame(
  "diam" = as.numeric(Inv_complet$Circonférence)/pi, # as num divided by pi
  "essence" = as.factor(Inv_complet$Nom_Vern), # as factor
  "age" = Inv_complet$Age_Plantation_annee # converted in year
)

# Réduire à un seul point par 'age' et 'essence' en moyennant les duplicats
Obs_diam_averaged <- Obs_diam %>%
  group_by(age, essence) %>%
  summarise(
    diam = mean(diam, na.rm = TRUE),  # Moyenne des diamètres
    .groups = "drop"  # Pour éviter de conserver l'information de regroupement
  )

# Modèles Chapman-Richards par essence
mods_diam <- Obs_diam_averaged %>%
  group_by(essence) %>%
  group_map(~ tryCatch(
    nls(diam ~ A*(1 - exp(-k*age))^m, data = .x, start = list(A=40,k=0.06,m=1.3)),
    error = function(e) NULL
  ))
names(mods_diam) <- unique(Obs_diam$essence)


ages_pred <- 0:60
essence <- unique(Obs_diam$essence)
# Prédictions diamètre
Pred_diam <- expand_grid(age = ages_pred, essence = essence) %>%
  group_by(essence) %>%
  mutate(diam = if (!is.null(mods_diam[[unique(essence)]]))
           predict(mods_diam[[unique(essence)]], newdata = data.frame(age=age))
         else NA)

# ---- Graphique : diamètre ----
ggplot() +
  geom_line(data = Pred_diam, aes(x = age, y = diam, color = essence), linewidth = 1) +
  geom_point(data = Obs_diam_averaged, aes(x = age, y = diam, color = essence), size = 1) +
  theme_minimal() +
  labs(x = "Âge (ans)", y = "Diamètre (cm)", color = "Essence") +
  scale_y_continuous(
    breaks = seq(0, max(Obs_diam$diam, na.rm = TRUE), by = 10),  # Espacement des étiquettes sur l'axe Y
    labels = scales::comma  # Option pour ajouter des séparateurs de milliers
  ) +
  theme(plot.title = element_text(face = "bold", size = 14)) 

```

```{r}
#| label: fig-haut-real
#| fig-cap: Modèles de croissance en hauteur avec données réelles (6 essences, 3 parcelles)
#| echo: false

# Retirer les NA dans la colonne Hauteur_Totale
Inv_complet <- Inv_complet[!is.na(Inv_complet$Hauteur_Totale), ]

# ---- Selection des Données de hauteur par essence ----
Obs_haut <- data.frame(
  "haut" = as.numeric(Inv_complet$Circonférence), # as num
  "essence" = as.factor(Inv_complet$Nom_Vern), # as factor
  "age" = Inv_complet$Age_Plantation_annee # converted in year
)

# Reduction to one point by 'age' and 'essence' by averaging duplicats
Obs_haut_averaged <- Obs_haut %>%
  group_by(age, essence) %>%
  summarise(
    haut = mean(haut, na.rm = TRUE),  # Mean of diameters
    .groups = "drop"  # Pour éviter de conserver l'information de regroupement
  )

# ---- Modèles Chapman-Richards par essence ----
mods_haut <- Obs_haut_averaged %>%
  group_by(essence) %>%
  group_map(~ tryCatch(
    nls(haut ~ A*(1 - exp(-k*age))^m, data = .x, start = list(A=22,k=0.05,m=1.2)),
    error = function(e) NULL
  ))
names(mods_haut) <- unique(Obs_haut$essence)

# Prediction parameters
ages_pred <- 0:60
essence <- unique(Obs_haut$essence)

# ---- Prédictions hauteur ----
Pred_haut <- expand_grid(age = ages_pred, essence = essence) %>%
  group_by(essence) %>%
  mutate(haut = if (!is.null(mods_haut[[unique(essence)]]))
           predict(mods_haut[[unique(essence)]], newdata = data.frame(age=age))
         else NA)

# ---- Graphique : Hauteur ----
ggplot() +
  geom_line(data = Pred_haut, aes(x = age, y = haut, color = essence), linewidth = 1) +
  geom_point(data = Obs_haut_averaged, aes(x = age, y = haut, color = essence), size = 1) +
  theme_minimal() +
  labs(
    x = "Âge (ans)",
    y = "Hauteur (m)",
    color = "Essence"
  ) +
  theme(plot.title = element_text(face = "bold", size = 14))

```

## Modèle de Mortalité (TODO : Créer une référence de tout les Arbres plantés à l'état initiale, avec leur Code_Arbre)

```{r}
#| label: fig-mort-real
#| fig-cap: Modèles de mortalité avec données réelles (6 essences, 3 parcelles)
#| echo: false


# ---- MORTALITY DATA ----

# ---- Selection des Données de hauteur par essence ----
Obs_mort <- data.frame(
  "etat_san" = as.factor(Inv_complet$Circonférence), # as factor
  "essence" = as.factor(Inv_complet$Nom_Vern), # as factor
  "age" = Inv_complet$Age_Plantation_annee # converted in year
)

# Define reference for mortality percentage calculation
ref_parcelle <- length(unique(Inv_complet$Code_Arbre))
# Reduct to one point by 'age' and 'essence' by counting death and computing mortality percentage
Obs_mort_percent <- Obs_mort %>%
  group_by(age, essence) %>%
  summarise(
    mort = (sum(etat_san == 5, na.rm = TRUE) / ref_parcelle) * 100,  # Computing mortality percentage, without NA
    .groups = "drop"  # Pour éviter de conserver l'information de regroupement
  )
# Cumulate mortality percent
Obs_mort_percent <- Obs_mort_percent %>%
  group_by(essence) %>%  # Regrouper par essence seulement
  arrange(essence, age) %>%  # Trier par essence et âge croissant
  mutate(
    mort_cumul = cumsum(mort)  # Cumul des pourcentages de mortalité, incluant les âges précédents
  ) %>%
  ungroup()  # Désagréger les regroupements

# ---- MODELS ----

# Modèles logistiques par essence
mods_mort <- Obs_mort_percent %>%
  group_by(essence) %>%
  group_map(~ tryCatch({
    nls(mort_cumul ~ 100 / (1 + exp(-(a + b*age))),
        data = .x,
        start = list(a = -5, b = 0.1))
  }, error = function(e) NULL))
names(mods_mort) <- unique(Obs_mort$essence)

# Prediction parameters
ages_pred <- 0:60
essence <- unique(Obs_mort$essence)

# Prédictions mortalité
Pred_mort <- expand_grid(age = ages_pred, essence = essence) %>%
  group_by(essence) %>%
  mutate(mort_cumul = if (!is.null(mods_mort[[unique(essence)]]))
           predict(mods_mort[[unique(essence)]], newdata = data.frame(age=age))
         else NA)

# ---- Graphique : mortalité ----
ggplot() +
  geom_line(data = Pred_mort, aes(x = age, y = mort_cumul, color = essence), linewidth = 1) +
  geom_point(data = Obs_mort_percent, aes(x = age, y = mort_cumul, color = essence), size = 1) +
  theme_minimal() +
  labs(x = "Âge (ans)", y = "Mortalité cumulée (%)", color = "Essence") +
  theme(plot.title = element_text(face = "bold", size = 14))

```

## Modèle de production de Bois d’œuvre
