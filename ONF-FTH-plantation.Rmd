---
title: "Étude du comportement de plusieurs essences en plantation de bois d'oeuvre, Guyane Française"
author:
  - name: "Maël Leborgne"
    authsuperscript: 1*
    orcid: 0000-0000-0000-0000
  - name: "Rozenn Bourquin"
    authsuperscript: 2
affiliation:
  - affsuperscript: 1
    dptuniv: "Department / University"
    address: >
      Street address,
      Zip code,
      Country.
  - affsuperscript: 2
    dptuniv: "Department / University"
    address: >
      Street address,
      Zip code,
      Country.
corrauthor:
    email: name@company.com
    url: https://www.company.com
abstract: >
  Summary of the article.
  Mandatory.
  
  
  Use double line feed for a new paragraph.
keywords: [keyword1, keyword2, etc]
JEL: [Code1, Code2, etc, MayBeDeleted]
acknowledgements: >
  Acknowledgements. 
  
  
  May be deleted.
journalinfo: "Publication reference"
archive: "DOI: xxx/xx"
# Date format: '%Y %B %d' for distill
date: "`r format(Sys.time(), '%Y %B %d')`"
url: https://GitHubID.github.io/Repository/
github-repo: GitHubID/Repository
lang: en-US
otherlangs: [fr-FR,it]
keywordlabel: Keywords
JELlabel: JEL
acknowledgementslabel: Acknowledgements
corrauthorlabel: Corresponding author
# Author separator: \par (no quote) for one author per line, "," (between quotes) else
authorseparator: \par
bibliography: references.bib
biblio-style: chicago
toc-depth: 3
fontsize: 10pt
urlcolor: blue
preamble: >
  \hyphenation{bio-di-ver-si-ty sap-lings}
always_allow_html: yes
csquotes: true
output:
  bookdown::html_document2:
    base_format: distill::distill_article
    toc: yes
    toc_float: yes
    code_folding: show
    highlight_downlit: yes
  rmdformats::downcute:
    use_bookdown: yes
    lightbox: yes
  bookdown::gitbook:
    config:
      download: "pdf"
      sharing:
        github: yes
  bookdown::pdf_book:
    template: latex/template.tex
    citation_package: natbib
    latex_engine: xelatex
    keep_tex: yes
  bookdown::word_document2: default
editor_options: 
  markdown: 
    wrap: sentence
---

```{r}
#| label: DoNotModify
#| include: false
### Utilities. Do not modify.
# Installation of packpred if necessary
install_packpred <- function(packpred) {
  install_package <- function(package) {
    if (!package %in% installed.packages()[, 1]) {
      install.packages(package, repos = "https://cran.rstudio.com/")
    }
  }
  invisible(sapply(packpred, install_package))
}

# Basic packpred
install_packpred(c("bookdown", "formatR", "kableExtra", "ragg"))

# Chunk font size hook: allows size='small' or any valid Latex font size in chunk options
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(
    options$size != "normalsize", 
    paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), 
    x
  )
})
```

```{r}
#| label: Options
#| include: false
### Customized options for this document
# Add necessary packpred here
packpred <- c("tidyverse")
# Install them
install_packpred(packpred)

# knitr options
knitr::opts_chunk$set(
  cache =   FALSE,    # Cache chunk results
  include = TRUE,     # Show/Hide chunks
  echo =    TRUE,     # Show/Hide code
  warning = FALSE,    # Show/Hide warnings
  message = FALSE,    # Show/Hide messpred
  # Figure alignment and size
  fig.align = 'center', out.width = '80%',
  # Graphic devices (ragg_png is better than standard png)
  dev = c("ragg_png", "pdf"),
  # Code chunk format
  tidy = TRUE, tidy.opts = list(blank = FALSE, width.cutoff = 50),
  size = "scriptsize", knitr.graphics.auto_pdf = TRUE
  )
options(width = 50)

# ggplot style
library("tidyverse")
theme_set(theme_bw())
theme_update(
  panel.background = element_rect(fill = "transparent", colour = NA),
  plot.background = element_rect(fill = "transparent", colour = NA)
)
knitr::opts_chunk$set(dev.args = list(bg = "transparent"))

# Random seed
set.seed(973)
```

# Introduction

## Contexte

La Guyane française est un territoire de 84 millions d'hectares (Mha).
La majorité (96%) de la surface de cette région d'Amérique latine est recouverte par la forêt Amazonienne.
Depuis 2005, l'office nationale des forêts (ONF) exploite le domaine forestier permanent (DFP) qui correspond à une zone de 2,4 Mha et qui forme une bande entre les zones habitées sur le littorale et les forêts non exploitées.
Cette zone de forêt naturelle est exploitée selon des règles de gestion durable du label PEFC.
Ces règles comprennent des rotations de 65 ans entre 2 coupes, une intensité d’exploitation de 5 tiges/ha et la mise en place de séries d’intérêt écologique d’où l’exploitation forestière est exclue.
L’exploitation forestière, malgré un large éventail d’espèces (100) technologiquement utilisables et de qualité remarquable, n’exploite que 15 à 30 espèces et se concentre sur seulement 3 espèces.
Or les pratiques d’exploitation actuelles ne permettent pas la reconstitution du volume commercial en fin de rotation (Piponiot et al 2019).

Aux enjeux de conservation et protection de la forêt, s'ajoute un enjeu de démographie.
En effet, la Guyane connaît une forte croissance démographique (+1,7% par ans entre 2020 et 2023) (INSEE, 2019).
Cette croissance démographique entraîne une augmentation de la demande en logement, et donc en bois d’œuvre.
Ainsi la filière Forêt-Bois prévoit le développement des modèles de plantation forestière dans son Programme Régionale de la Forêt et du Bois 2019-2029 (PRFB) avec un objectif de 5 000 hectares de plantation supplémentaires.

Le dévellopement du modèle de plantation forestière nécessite un état des lieux des plantations actuelles de l'ONF en Guyane.
Le derniers rapport de suivi fait le bilan de XX parcelles expérimentales pour XX espèces avec un recul de XX années pour certaines d'entre elles (Nicolini, 2023).
L'édition d'un nouvel article est motivé par la nécessité de mettre à jour la base de données avec un nouvel inventaire et de synthétiser l’ensemble des données afin d'émettre des recommandations sur les essences à développer en plantation de Bois d’œuvre.

## Objectifs

1.  Comparer les performances des essences

2.  Adapter le choix des essences aux sites (sol, précipitations, FWI)

3.  Tester des scénarios de gestion (densité de plantation, plantation multispecifiques, modalités de préparation de la parcelle, fréquence d'entretient)

# Matériel et méthode {#markdown}

## Importation des données

```{r}
#| echo: false
library(tidyverse)
library(brms)

Inv_complet <- read.csv2("/home/jean/Bureau/projet-ONF-FTH/Data/Rozeen_30-10_DataPlantations_sansBR.csv", sep=";",dec = ",")

# Mise en facteurs de cetraines variables
Inv_complet$Code_Essence <- as.factor(Inv_complet$Code_Essence)

# ---- Convertion de Age_Plantation en années ----
convert_annee <- data.frame(
  "Age_Plantation" = unique(Inv_complet$Age_Plantation),
  "Age_Plantation_annee" = c(35,0,0.5,1,1.5,2,3,5,8,9,14,7,36,46,3.5,4,6,10.5,2.5,0,34,20,40,0.25,15,0.75,0.917,1.083,1.5,10,0.583,23,7,41,13,4.5)
)
Inv_complet <- left_join(Inv_complet,convert_annee,by="Age_Plantation")

# ---- Set Ht_mesure at 130 for those are set at 0 ----
Inv_complet <- Inv_complet %>%
  mutate(Ht_Mesure = ifelse(Ht_Mesure == 0, 130, Ht_Mesure))

# ---- Correction des diametres à 130cm ----
Inv_complet <- Inv_complet |>
  mutate(DBH = round(Circonférence/pi),digits=2) |>
  mutate(POM = Ht_Mesure) |>
  mutate(Taper_parameter = 0.156 - 0.023*log(DBH) - 0.021*log(POM/100)) |>
  mutate(DBHCorr = DBH/(exp(- Taper_parameter*((POM-130)/100))))

# ---- do DBHCorr = 0 if DBH = 0 ----
Inv_complet <- Inv_complet %>%
  mutate(DBHCorr = ifelse(DBH == 0, 0, DBHCorr))

# ---- Adding initial diameter and high for all trees ----
tree_with_starting_point <- unique(Inv_complet[Inv_complet$Age_Plantation_annee==0,]$Code_Arbre)
tree_no_starting_point <- unique(Inv_complet[Inv_complet$Code_Arbre %in% tree_with_starting_point,]$Code_Arbre)     # All trees
Initial_state <- data.frame(                         # Inisialized
  "Code_Arbre" = all_trees_code,
  "Age_Plantation_annee" = rep(0,length(all_trees_code)),
  "DBHCorr" = rep(0,length(all_trees_code)),
  "Hauteur_Totale" = rep(0,length(all_trees_code))
)
# Make correspondance with Code_Essence, Nom_Vernaculaire, Famille, Genre, Espece
ref_code_espece <- Inv_complet %>% distinct(Code_Arbre, .keep_all = TRUE)                                      # first make a reference
ref_code_espece <- ref_code_espece |> select("Code_Arbre", "Nom_Vernaculaire", "Famille", "Genre", "Espece") # then select rows of interest
Initial_state   <-  left_join(Initial_state, ref_code_espece, by="Code_Arbre")                               # Make the correspondance for each Code_Arbre

# Finally Bind Initial_state to Inv_complet
Inv_complet <- bind_rows(Inv_complet,Initial_state)

# ---- Ajouter les mort au années suivantes ----
all_species <- unique(Inv_complet$Nom_Vernaculaire)
for (specie in all_species) { # for each specie
  data_specie <- Inv_complet[Inv_complet$Nom_Vernaculaire == specie,]
  
  all_ages <- unique(data_specie$Age_Plantation_annee) %>%
    sort(decreasing = FALSE) # Sort age increas
  for (i in 2:length(all_ages)) { # for each next year (begin on 2de inventory)
    tree_before <- data_specie[data_specie$Age_Plantation_annee==all_ages[i-1],]$Code_Arbre %>% # the previous age
      unique()
    tree_current <- data_specie[data_specie$Age_Plantation_annee==all_ages[i],]$Code_Arbre %>% # the current age
      unique()
    missing_tree <- tree_before[!tree_before %in% tree_current] # previous tree not in current age
    
    # prepare NaN line with same structure than Inv_complet
    line_NaN <- t(data.frame("new_line"=rep(NaN, ncol(Inv_complet))))
    line_NaN <- as.data.frame(line_NaN)
    names(line_NaN) <- names(Inv_complet)
    
    for (tree in missing_tree) { # Add missing tree at dead state
      current_line <- line_NaN %>%
        mutate(                  # Fill target information for current line
          Code_Arbre = tree, # basic information
          Age_Plantation_annee = all_ages[i], # current age where tree is missing
          Etat_Sanitaire = 5, # dead trees
          note_inventaire = "Dead trees added in the data importation"
          ) 
      Inv_complet <- rbind(Inv_complet, current_line) # Add the new line
    }
  }
}
# Verification of good death completing
table(Inv_complet$Age_Plantation_annee)

# Check doublons age/arbre

# ---- Verification of variables types ----
str(Inv_complet)


```

## Modèle de croissance et d'accroissement

Un **modèle de croissance forestier** est un outil mathématique qui permet de prédire l’évolution d’un arbre ou d’un peuplement au cours du temps (source).
On peut donc estimer l'évolution de la croissance en diamètre, en hauteur, ou en volume du bois à partir de **mesures dendrométriques**, de **variables écologiques** et du **scénario de gestion**.

**Modèle de** **Michaelis-Menten :**

$$
Y(t)=\frac{Y_{max}*t}{K_m+t}
$$

$Y(t)$ : La variable de croissance à modéliser en fonction du temps (Diamètre ou Hauteur),\
$t$ : âge des arbres en année,\
$Y_{max}$ : Valeur maximal théorique de Y (à estimer),\
$K_m$ : constante de Michaelis (à estimer).

### Accroissement en Diamètre

Pré-traitement (k-nearest neighbors, split train and test)

```{r}
# ---- Selection des Données de diamètres par essence ----
Obs_diam <- data.frame(
  "arbre" = Inv_complet$Code_Arbre,
  "diam" = Inv_complet$DBHCorr,
  "essence" = as.factor(Inv_complet$Nom_Vern), # as factor
  "age" = Inv_complet$Age_Plantation_annee # converted in year
)

# ---- Sous écantillonage pour test ----
Obs_diam <- Obs_diam[Obs_diam$essence %in% c("angelique"),]

# ---- Linear Model ----
mod1 <- lm(log(diam) ~ log(age),data = Obs_diam[Obs_diam$diam!=0,])
# extract coefficients
int <- coef(mod1)[1] # intercept
bla <- coef(mod1)[2] # slope

# ---- Graph ----
ggplot(data = Obs_diam[Obs_diam$diam!=0,], aes(x = log(age), y = log(diam))) +
  geom_abline(aes(slope = bla,
                  intercept = int, 
                  col='Linear model')) +
  geom_point() +
  theme_minimal() +
  labs(y = "diamètre estimé", x = "âge", title = "Modèle bayésien Michaelis–Menten par essence")


```

```{r}
# # load libraries
# library(rjags)
# library(ggmcmc)
# library(ggExtra)
# library(tidyverse)
# library(gridExtra)
# 
# # construct and run model
# my.model <- "
# model{
#   ## PRIORS
#   # intercept and fixed effect
#   Ymax ~ dnorm(0,0.001)
#   Km  ~ dnorm(0,0.001)
#   
#   ## residuals
#   sigma.resid ~ dunif(0,20)
#   tau.resid <- 1/(sigma.resid*sigma.resid)
# 
#   ## LIKELIHOOD
#   for (n in 1:N) {
#     DBH[n] ~ dlnorm(mu[n], tau) # Lognormal likelihood
#     mu[n] <- alpha + beta * log(H[n]) # Linear model for the mean
#   }
#   for(ind in 1:N) {
#     diam[ind] <- (Ymax * age[ind]) / (Km + age[ind])
#     age[i] ~ dnorm(mu[i],tau.resid)
#   }
# }"
# 
# n_chains = 3
# n_burn = 1000
# first_model <- jags.model(file=textConnection(my.model), 
#                      data = my.data,  
#                      n.chains = n_chains, 
#                      n.adapt = n_burn,
#                      quiet = FALSE)
# 
# # params to track
# my.params <- c('b.intercept', 'b.black', 'sigma.resid')
# 
# n_iter <- 11000 # number of iterations
# n_thin <- 10 # step between two stocked iterations
# 
# samples_posterior_mcmc <- coda.samples(model = first_model, 
#                                             variable.names = my.params, 
#                                             n.iter = n_iter,
#                                             thin = n_thin)
```

```{r}
#| label: fig-diam-real
#| fig-cap: Modèles de croissance en diamètre avec données réelles (23 essences)
#| echo: false

# ---- Selection des Données de diamètres par essence ----
Obs_diam <- data.frame(
  "arbre" = Inv_complet$Code_Arbre,
  "diam" = Inv_complet$DBHCorr,
  "essence" = as.factor(Inv_complet$Nom_Vern), # as factor
  "age" = Inv_complet$Age_Plantation_annee # converted in year
)

# ---- Sous écantillonage pour test ----
Obs_diam <- Obs_diam[Obs_diam$essence %in% c("angelique"),]

# ---- Standardisation ----
mean_age <- mean(Obs_diam$age, na.rm = TRUE)
sd_age   <- sd(Obs_diam$age, na.rm = TRUE)
mean_diam <- mean(Obs_diam$diam , na.rm = TRUE)
sd_diam   <- sd(Obs_diam$diam, na.rm = TRUE)
# Create standardized columns
Obs_diam$age_s <- (Obs_diam$age-mean_age)/sd_age
Obs_diam$diam_s <- (Obs_diam$diam-mean_diam)/sd_diam

# ____ Michaelis-Menten Model by species with Bayesian methode (5 Steps) ____

# ---- Step 1 – Defining the base of Michaelis–Menten model ----
form_mm <- bf(
  diam_s ~ (Ymax * age_s) / (Km + age_s), # Model of Mickaelis-Menten for the diameter
  Ymax ~ 1 + (1 | arbre),   # effets de groupe essence
  Km   ~ 1 + (1 | arbre),
  nl = TRUE
)

# ---- Step 2 – Defining reasonable priors ----
# Michaelis–Menten parameters are alway positive,
# So distribution are troncated or lognormales.
priors_mm <- c(
  prior(normal(1, 2), nlpar = "Ymax", lb = 0, class="b"),
  prior(normal(0, 2), nlpar = "Km", lb = 0, class="b"),
  prior(exponential(1), nlpar = "Ymax", class = "sd", group = "arbre"),
  prior(exponential(1), nlpar = "Km", class = "sd", group = "arbre"),
  prior(student_t(3, 0, 2.5), class = "sigma")
)

# ---- Step 3 – Ajusting the model ----
mod_mm_bayes <- brm(
  data = Obs_diam,   # Data
  formula = form_mm, # Defined model
  prior = priors_mm, # Defined priors
  control = list(adapt_delta = 0.95, max_treedepth = 12), # other bayesian parameters
  iter = 2000, chains = 4, cores = 4,
  seed = 123
)

# ---- Step 4 – Verify and summarise ----
summary(mod_mm_bayes)
plot(mod_mm_bayes)
pp_check(mod_mm_bayes)
# Effects by specie and individuals
coef(mod_mm_bayes)
ranef(mod_mm_bayes)

# # ---- De-standardise coeff ----
# Ymax <- Ymax_s * sd(Obs_diam$diam) + mean(Obs_diam$diam)
# Km <- Km_s * sd(Obs_diam$age) + mean(Obs_diam$age)

# ---- Step 5 – Visualization of curves by specie ----
newdata <- expand.grid(
  age = seq(min(Obs_diam$age), max(Obs_diam$age), length.out = 100),
  essence = unique(Obs_diam$essence)
)

preds <- fitted(mod_mm_bayes, newdata = newdata)
newdata <- cbind(newdata, preds)

ggplot(newdata, aes(age, Estimate, color = essence)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5, fill = essence), alpha = 0.2) +
  geom_point(data = Obs_diam, aes(x = age, y = diam, color = essence), size = 1) +
  theme_minimal() +
  labs(y = "diamètre estimé", x = "âge", title = "Modèle bayésien Michaelis–Menten par essence")


```

### Croissance en hauteur

```{r}
#| label: fig-haut-real
#| fig-cap: Modèles de croissance en hauteur avec données réelles (23 essences)
#| echo: false

# ---- Retirer les NA dans la colonne Hauteur_Totale ----
Inv_complet <- Inv_complet[!is.na(Inv_complet$Hauteur_Totale), ]

# ---- Selection des Données de hauteur par essence ----
Obs_haut <- data.frame(
  "arbre" = Inv_complet$Code_Arbre,
  "haut" = as.numeric(Inv_complet$Hauteur_Totale), # as num
  "essence" = as.factor(Inv_complet$Nom_Vern), # as factor
  "age" = Inv_complet$Age_Plantation_annee # converted in year
)

# ---- Modèles Mickaelis-Menten par essence ----
mods_haut <- Obs_haut %>%
  group_by(essence) %>%
  group_map(~ tryCatch(
    nls(haut ~ (Y_max * age) / (K_m + age), data = .x, start = list(A=22,k=0.05,m=1.2)),
    error = function(e) NULL
  ))
names(mods_haut) <- unique(Obs_haut$essence)

# ---- Prédictions hauteur ----
ages_pred <- 0:60                       # vector of ages
essence <- unique(Obs_haut$essence)     # vector of trees
Pred_haut <- expand_grid(age = ages_pred, essence = essence) %>%      # dataframe of haut predicted
  group_by(essence) %>%
  mutate(haut = if (!is.null(mods_haut[[unique(essence)]]))
           predict(mods_haut[[unique(essence)]], newdata = data.frame(age=age))
         else NA)

# ---- Graphique of data + prediction : total high ----
ggplot() +
  geom_point(data = Obs_haut_averaged, aes(x = age, y = haut, color = essence), size = 1) +
  geom_line(data = Pred_haut, aes(x = age, y = haut, color = essence), linewidth = 1) +
  theme_minimal() +
  labs(
    x = "Âge (ans)",
    y = "Hauteur (m)",
    color = "Essence"
  ) +
  theme(plot.title = element_text(face = "bold", size = 14))

```

## Modèle de production de Bois d’œuvre

La combinaison du modèle de croissance et du modèle de mortalité permet d'obtenir un modèle de production volumique.

Soit le volume individuel d'un arbre :

$$
V_{ind}=\pi*(\frac{DBH}{2})²*H_{tot}
$$

Avec $DBH$ le diamètre du tronc en mètre à 130 cm,\
$H_{tot}$ la hauteur totale de l'arbre,\
et $f$ le facteur de forme.

```{r}
#| label: fig-prod-fictive
#| fig-cap: Modèles de production de Bois d'oeuvre avec données fictives (10 essences)
#| echo: false

# ---- Paramètres sylvicoles ----
surf <- 1 # hectare

# ---- Fonction de volume individuel ----
calc_volume <- function(D,H){
  V <- pi * (D/200)^2 * H # volume du cylindre en m³
  return(V)
}

# ---- Observed individual volumes (OIV) ----
vol_obs_ind <- left_join(Obs_diam,Obs_haut,by=c("arbre","essence","age")) %>%
  mutate(V_ind = calc_volume(diam,haut))

# ---- Sum of OIV's ----
vol_obs_sum <- vol_obs_ind |>
    group_by(essence, age) |>
    summarise(Vol_ha = sum(V_ind) / surf) # volume par hectare (avec surface de parcelle = 1ha)

# ---- Predicted individual volume (PIV) ----
vol_pred <- left_join(Pred_diam,Pred_haut,by=c("age","essence")) %>%
  mutate(V_ind = calc_volume(diam,haut))

# ---- Sum of PIV's ----
vol_pred_sum <- vol_obs_ind |>
    group_by(essence, age) |>
    summarise(Vol_ha = sum(V_ind) / surf) # volume par hectare (avec surface de parcelle = 1ha)

# ---- Graphique : volume ----
ggplot() +
  #geom_point(data = vol_obs_sum, aes(x = age, y = Vol_ha, color = essence), size = 1, shape = 16) +
  geom_line(data = vol_pred_sum, aes(x = age, y = Vol_ha, color = essence), linewidth = 1) +
  theme_minimal() +
  labs(x = "Âge (ans)", y = "Volume total (m³/ha)", color = "Essence") +
  theme(plot.title = element_text(face = "bold", size = 14))

```

Un autre point important en sylviculture est l'estimation de la **rotation optimale**, c'est à dire l'âge idéal de coupe pour maximiser la valeur du Bois.

## Survie

```{r}

data <- Inv_complet[Inv_complet$Nom_Vernaculaire %in% c("angelique"),] %>%
  select(Code_Arbre,DBHCorr,Nom_Vernaculaire,Age_Plantation_annee,Etat_Sanitaire)

unique_ages <- unique(data$Age_Plantation_annee)
Nb_ages <- length(unique_ages)
Pm <- data.frame(# Probabilité fréquentiste de mortalité pour chaque intervale de temps
  "Age" = unique_ages,
  "Nmt" = rep(0,Nb_ages), # Nombre de Morts totale
  "Nms" = rep(0,Nb_ages), # Nombre de Morts supplémentaire à l'année précédent
  "Nv" = rep(0,Nb_ages), # Nombre de Vivant
  "Prob" = rep(0,Nb_ages), # Probabilité fréquentiste de mortalité pour chaque intervale de temps
  "NCI" = rep(0,Nb_ages) # Indice de Compétition
) 

# Remplissage des nombre de mort et vivant par année
for (i in Nb_ages) {
  data_age <- data[data$Age_Plantation_annee==Pm$Age[i],]
  Pm$Nmt[i] <- length(data_age[data_age$Etat_Sanitaire==5,])
  Pm$Nv[i] <- length(data_age[data_age$Etat_Sanitaire!=5,])
}

for (i in Nb_ages) {
  # Sélectionner selon l'annee et le Nom_Vern
  TON_year_tot <- TON_year %>% filter(annee == a & Nom_Vern == n)
  # Sélectioner les mort parmis eux
  TON_year_mort <- TON_year_tot %>% filter(Etat==5)
  # Calucle de la mortalité
  df_sum$mortality[i] <- nrow(TON_year_mort) / nrow(TON_year_tot)
}

```

```{r}
# ---- Selection of Data for NCI calculation ----
data_NCI <- data.frame(
  "arbre" = Inv_complet$Code_Arbre,
  "DBHCorr" = Inv_complet$DBHCorr,
  "essence" = as.factor(Inv_complet$Nom_Vern), # as factor
  "age" = Inv_complet$Age_Plantation_annee, # converted in year
  "Xutm" = Inv_complet$X_utm,
  "Yutm" = Inv_complet$Y_utm
)

# ---- Sous écantillonage pour test ----
data_NCI <- data_NCI[data_NCI$essence %in% c("angelique"),]

# #Calcul du NCI
# data_NCI <- data_NCI |> # data = jeu de donnée initial
#   filter(age == 15,CodeAlive=TRUE) #|> #Filtre sur l'année pour laquelle vous voulez calculer le NCI (si plusieurs année il faudra faire un groupe by année et calculer la moyenne dans la boucle principale)
#   #select(Plot.x,idTree,Xutm,Yutm,CensusYear,Circ,POM) # Sélection des variables d'intérêt


# data_NCI <- data_NCI |> #Correction du diamètre de la même manière que je vous avais déjà montré si c'est déja fait pas besoin de ce code)
#   mutate(DBH = Circ/pi) |>
#   mutate(Taper_parameter = 0.156 - 0.023*log(DBH) - 0.021*log(POM/100)) |>
#   mutate(DBHCorr = DBH/(exp(- Taper_parameter*((POM-130)/100)))) |>
#   select(-Taper_parameter)

x = c() #Initialisation du vecteur nul qui stockera les NCI calculés
for (ind in 1:nrow(data_NCI)){ #On parcours chaque arbre
  NC <- data_NCI |>
    mutate(dij = sqrt((data_NCI$Xutm[ind] - Xutm)^2+(data_NCI$Yutm[ind] - Yutm)^2)) #Création d'un champ distance à l'arbre focal (ind) dans le tableau NC 
  NCI = sum(NC$DBHCorr[which(NC$dij < 20)]*NC$DBHCorr[which(NC$dij < 20)]*exp(-0.25*NC$dij[which(NC$dij < 20)])) - #Calcul du NCI en prenant uniquement les arbres à moins de 20 m de l'arbre focal
    NC$DBHCorr[ind]*NC$DBHCorr[ind]*exp(-0.25*NC$dij[ind]) #On soustrait le NCI calculé pour notre arbre focal (il n'exerce pas de compétition sur lui même)
  x <- c(x,NCI) # Stock du NCI calculé
}
NCI <- cbind(data_NCI,x) |> # On récupère le vecteur comprenant tous les NCI dans notre jeu de donné et on convertit en m² (valeur en cm² initialement et ça fais des gros chiffres)
  rename(NCI = x) |> 
  mutate(NCI = NCI/10000) |> 
  select(arbre,NCI)


##### Ensuite on va corriger l'effet bordure des arbres ######
geometree <- epure_data_sf |> #Ici epure_data_sf c'est le jeu de donné qui contient uniquement nos arbres dont on regarde la croissance (Pour le NCI on regardait tous les arbres vivants à l'année cible)
  select(arbre,geometry) # on extrait la géométrie et idtree -> geometree (c'est hilarant)

NCICorr <- left_join(geometree,NCI,by="idTree") # On ajoute la geometry au NCI


NCICorr <- NCICorr |> 
  mutate(Area_intersect = st_area(st_intersection(st_buffer(intersect_LG_placette$geometry,dist = 20),placette))) |> #Ici on crée un champ qui calcul la surface d'intersection entre un buffer de 20m de rayon autour de l'arbre focal et notre placette d'étude
  drop_units() |> 
  mutate(NCIcorr = if_else(Area_intersect==400*pi, NCI,NCI*400*pi/Area_intersect)) |> # Si la surface d'intersection est égale à 400pi(= un cercle de 20 m de rayon) alors on conserve le NCI (pas d'effet bordure)
                                                                                      # Mais si ce n'est pas le cas ça veut dire qu'une partie du cercle est en dehors de la placette et donc qu'on a pas l'info de la compétition des arbres là
                                                                                      #Ducoup  déduit le NCI des arbres de bordure proportionellement, c'est une estimation
  select(-NCI,-Area_intersect,-geometry) |> 
  st_drop_geometry()
#Et voila vous avez votre NCI corriger pour vos arbres d'intérêt
```

# TODO :

1.  Change nls() to brms()

2.  Add surface of plots in the volume model

3.  Add data from 2025

4.  Tout traduire en Anglais
